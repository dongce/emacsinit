# -*- coding: utf-8; -*-


* xah blog content
** encoding 
#+BEGIN_SRC emacs-lisp 
;; -*- coding: utf-8; -*-
#+END_SRC
#+BEGIN_SRC emacs-lisp

(setq minibuffer-prompt-properties
      (quote (read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)))

;; http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html

(defvar xah-switch-buffer-ignore-dired t "If t, ignore dired buffer when calling `xah-next-user-buffer' or `xah-previous-user-buffer'")
(setq xah-switch-buffer-ignore-dired t)

(defun xah-next-user-buffer ()
  "Switch to the next user buffer.
 “user buffer” is a buffer whose name does not start with “*”.
If `xah-switch-buffer-ignore-dired' is true, also skip directory buffer.
2015-01-05 URL `http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html'"
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (or
           (string-equal "*" (substring (buffer-name) 0 1))
           (if (string-equal major-mode "dired-mode")
               xah-switch-buffer-ignore-dired
             nil
             ))
          (progn (next-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))

(defun xah-previous-user-buffer ()
  "Switch to the previous user buffer.
 “user buffer” is a buffer whose name does not start with “*”.
If `xah-switch-buffer-ignore-dired' is true, also skip directory buffer.
2015-01-05 URL `http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html'"
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (or
           (string-equal "*" (substring (buffer-name) 0 1))
           (if (string-equal major-mode "dired-mode")
               xah-switch-buffer-ignore-dired
             nil
             ))
          (progn (previous-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))

(defun xah-next-emacs-buffer ()
  "Switch to the next emacs buffer.
 (buffer name that starts with “*”)"
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (not (string-equal "*" (substring (buffer-name) 0 1))) (< i 20))
      (setq i (1+ i)) (next-buffer))))

(defun xah-previous-emacs-buffer ()
  "Switch to the previous emacs buffer.
 (buffer name that starts with “*”)"
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (not (string-equal "*" (substring (buffer-name) 0 1))) (< i 20))
      (setq i (1+ i)) (previous-buffer))))



(defun xah-replace-BOM-mark-etc ()
  "Query replace some invisible Unicode chars.
The chars to be searched are:
 ZERO WIDTH NO-BREAK SPACE (codepoint 65279, #xfeff)
 RIGHT-TO-LEFT MARK (codepoint 8207, #x200f)
 RIGHT-TO-LEFT OVERRIDE (codepoint 8238, #x202e)

Search begins at buffer beginning (respects `narrow-to-region').

This is useful for text copied from twitter or Google Plus, because they often contain BOM mark. See URL `http://xahlee.info/comp/unicode_BOM_byte_orde_mark.html'

URL `http://ergoemacs.org/emacs/elisp_unicode_replace_invisible_chars.html'
Version 2015-10-11"
  (interactive)
  (progn
    (goto-char (point-min))
    (query-replace-regexp "\u200f\\|\u202e\\|\ufeff" "")))






(defun xah-replace-BOM-mark-dir ()
  "temp hack. replace some invisible Unicode chars.
see `xah-replace-BOM-mark-etc'
Version 2015-10-11"
  (interactive)
  (require 'xah-find)
  (let (ξdir)
    (setq ξdir (ido-read-directory-name "Directory: " default-directory default-directory "MUSTMATCH"))
    (xah-find-replace-text (char-to-string 65279) "" ξdir "\\.html\\'" t t t t)))



;;(setenv "ERGOEMACS_KEYBOARD_LAYOUT" "us") ; US

(add-to-list 'load-path (fullpath  "../../ergoemacs/packages/"))
(add-to-list 'load-path (fullpath  "../../ergoemacs/ergoemacs/ergoemacs-keybindings"))

;;(load-file 
;; (concat (file-name-directory (or load-file-name buffer-file-name)) "../../../ergoemacs/site-lisp/site-start.el"))

;;(require 'xah_file_util)



(use-package xah-math-input
  :config
  (define-key xah-math-input-keymap "\C-\\"  'xah-math-input-change-to-symbol)
  (define-key xah-math-input-keymap (kbd "S-SPC") 'toggle-korean-input-method))

(defun xah-search-current-word ()
  "Call `isearch' on current word or text selection.
“word” here is A to Z, a to z, and hyphen 「-」 and underline 「_」, independent of syntax table.
URL `http://ergoemacs.org/emacs/modernization_isearch.html'
Version 2015-04-09"
  (interactive)
  (let ( ξp1 ξp2 )
    (if (use-region-p)
        (progn
          (setq ξp1 (region-beginning))
          (setq ξp2 (region-end)))
      (save-excursion
        (skip-chars-backward "-_A-Za-z0-9")
        (setq ξp1 (point))
        (right-char)
        (skip-chars-forward "-_A-Za-z0-9")
        (setq ξp2 (point))))
    (setq mark-active nil)
    (when (< ξp1 (point))
      (goto-char ξp1))
    (isearch-mode t)
    (isearch-yank-string (buffer-substring-no-properties ξp1 ξp2))))


(progn
  ;; set arrow keys in isearch. left/right is backward/forward, up/down is history. press Return to exit
  (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
  (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )
  (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward) ; single key, useful
  (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward) ; single key, useful
 )




(defvar xah-recently-closed-buffers nil "alist of recently closed buffers. Each element is (buffer name, file path). The max number to track is controlled by the variable `xah-recently-closed-buffers-max'.")

(defvar xah-recently-closed-buffers-max 40 "The maximum length for `xah-recently-closed-buffers'.")


(defun xah-close-current-buffer ()
  "Close the current buffer.

Similar to `kill-buffer', with the following addition:

• Prompt user to save if the buffer has been modified even if the buffer is not associated with a file.
• If the buffer is editing a source file in an org-mode file, prompt the user to save before closing.
• If the buffer is a file, add the path to the list `xah-recently-closed-buffers'.
• If it is the minibuffer, exit the minibuffer

URL `http://ergoemacs.org/emacs/elisp_close_buffer_open_last_closed.html'
Version 2016-06-19"
  (interactive)
  (let (ξemacs-buff-p
        (ξorg-p (string-match "^*Org Src" (buffer-name))))

    (setq ξemacs-buff-p (if (string-match "^*" (buffer-name)) t nil))

    (if (string= major-mode "minibuffer-inactive-mode")
        (minibuffer-keyboard-quit) ; if the buffer is minibuffer
      (progn
        ;; offer to save buffers that are non-empty and modified, even for non-file visiting buffer. (because kill-buffer does not offer to save buffers that are not associated with files)
        (when (and (buffer-modified-p)
                   (not ξemacs-buff-p)
                   (not (string-equal major-mode "dired-mode"))
                   (if (equal (buffer-file-name) nil)
                       (if (string-equal "" (save-restriction (widen) (buffer-string))) nil t)
                     t))
          (if (y-or-n-p (format "Buffer %s modified; Do you want to save? " (buffer-name)))
              (save-buffer)
            (set-buffer-modified-p nil)))
        (when (and (buffer-modified-p)
                   ξorg-p)
          (if (y-or-n-p (format "Buffer %s modified; Do you want to save? " (buffer-name)))
              (org-edit-src-save)
            (set-buffer-modified-p nil)))

        ;; save to a list of closed buffer
        (when (buffer-file-name)
          (setq xah-recently-closed-buffers
                (cons (cons (buffer-name) (buffer-file-name)) xah-recently-closed-buffers))
          (when (> (length xah-recently-closed-buffers) xah-recently-closed-buffers-max)
            (setq xah-recently-closed-buffers (butlast xah-recently-closed-buffers 1))))

        ;; close
        (kill-buffer (current-buffer))))))


(defun xah-open-last-closed ()
  "Open the last closed file.
URL `http://ergoemacs.org/emacs/elisp_close_buffer_open_last_closed.html'
Version 2016-06-19"
  (interactive)
  (if (> (length xah-recently-closed-buffers) 0)
      (find-file (cdr (pop xah-recently-closed-buffers)))
    (progn (message "No recently close buffer in this session."))))

(defun xah-open-recently-closed ()
  "Open recently closed file.
Prompt for a choice.
URL `http://ergoemacs.org/emacs/elisp_close_buffer_open_last_closed.html'
Version 2016-06-19"
  (interactive)
  (find-file (ido-completing-read "open:" (mapcar (lambda (f) (cdr f)) xah-recently-closed-buffers))))

(defun xah-list-recently-closed ()
  "List recently closed file.
URL `http://ergoemacs.org/emacs/elisp_close_buffer_open_last_closed.html'
Version 2016-06-19"
  (interactive)
  (let ((ξbuf (generate-new-buffer "*recently closed*")))
    (switch-to-buffer ξbuf)
    (mapc (lambda (ξf) (insert (cdr ξf) "\n"))
          xah-recently-closed-buffers)))
#+END_SRC

** block movement

#+BEGIN_SRC emacs-lisp
(defun xah-forward-block (&optional φn)
  "Move cursor beginning of next text block.
A text block is separated by blank lines.
This command similar to `forward-paragraph', but this command's behavior is the same regardless of syntax table.
URL `http://ergoemacs.org/emacs/emacs_move_by_paragraph.html'
Version 2016-06-15"
  (interactive "p")
  (let ((φn (if (null φn) 1 φn)))
    (search-forward-regexp "\n[\t\n ]*\n+" nil "NOERROR" φn)))

(defun xah-backward-block (&optional φn)
  "Move cursor to previous text block.
See: `xah-forward-block'
URL `http://ergoemacs.org/emacs/emacs_move_by_paragraph.html'
Version 2016-06-15"
  (interactive "p")
  (let ((φn (if (null φn) 1 φn))
        (ξi 1))
    (while (<= ξi φn)
      (if (search-backward-regexp "\n[\t\n ]*\n+" nil "NOERROR")
          (progn (skip-chars-backward "\n\t "))
        (progn (goto-char (point-min))
               (setq ξi φn)))
      (setq ξi (1+ ξi)))))

(global-set-key (kbd "<S-next>") 'xah-forward-block)
(global-set-key (kbd "<S-prior>") 'xah-backward-block)
#+END_SRC

#+RESULTS:
: xah-backward-block

** pairedit

   #+BEGIN_SRC  emacs-lisp

     (use-package xah-replace-pairs
       :config
       (defun xah-css-compact-css-region (φbegin φend)
         "Remove unnecessary whitespaces of CSS source code in region.
     WARNING: not robust.
     URL `http://ergoemacs.org/emacs/elisp_css_compressor.html'
     Version 2015-04-29"
         (interactive "r")
         (save-restriction
           (narrow-to-region φbegin φend)
           (xah-replace-regexp-pairs-region
            (point-min)
            (point-max)
            '(["  +" " "]))
           (xah-replace-pairs-region
            (point-min)
            (point-max)
            '(
              ["\n" ""]
              [" /* " "/*"]
              [" */ " "*/"]
              [" {" "{"]
              ["{ " "{"]
              ["; " ";"]
              [": " ":"]
              [";}" "}"]
              ["}" "}\n"]
              ))))
       (defun xah-css-compact-css-string (φstr)
         "Remove unnecessary whitespaces of CSS source code in region.
     WARNING: not robust.
     URL `http://ergoemacs.org/emacs/elisp_css_compressor.html'
     Version 2015-04-29"
         (xah-replace-pairs-region
          (xah-replace-regexp-pairs-in-string φstr '(["  +" " "]))
          '(
            ["\n" ""]
            [" /* " "/*"]
            [" */ " "*/"]
            [" {" "{"]
            ["{ " "{"]
            ["; " ";"]
            [": " ":"]
            [";}" "}"]
            ["}" "}\n"]
            ))))
   #+END_SRC
** register
#+BEGIN_SRC emacs-lisp

  (defun xah-copy-to-register ( reg )
    "Copy current line or text selection to register 1.
  When no selection, copy current line, with newline char.
  See also: `xah-paste-from-register-1', `copy-to-register'.

  URL `http://ergoemacs.org/emacs/elisp_copy-paste_register_1.html'
  Version 2017-01-18"
    (interactive "p")
    (if (> 1 reg ) (setf reg 1 ))
    (let (-p1 -p2)
      (if (region-active-p)
          (progn (setq -p1 (region-beginning))
                 (setq -p2 (region-end)))
        (progn (setq -p1 (line-beginning-position))
               (setq -p2 (line-end-position))))
      (copy-to-register reg -p1 -p2)
      ;; (with-temp-buffer (insert "\n") (append-to-register reg (point-min) (point-max)))
      (message "Copied to register %d : 「%s」." reg (buffer-substring-no-properties -p1 -p2))))

  (defun xah-paste-from-register ( reg)
    "Paste text from register 1.
  See also: `xah-copy-to-register-1', `insert-register'.
  URL `http://ergoemacs.org/emacs/elisp_copy-paste_register_1.html'
  Version 2015-12-08"
    (interactive "p")
    (if (> 1 reg ) (setf reg 1 ))
    (when (use-region-p)
      (delete-region (region-beginning) (region-end)))
    (insert-register reg t))

  (defun xah-append-to-register( reg )
    "Append current line or text selection to register 1.
  When no selection, append current line with newline char.
  See also: `xah-paste-from-register-1', `copy-to-register'.

  URL `http://ergoemacs.org/emacs/elisp_copy-paste_register_1.html'
  Version 2015-12-08"
    (interactive "p")
    (if (> 1 reg ) (setf reg 1 ))
    (let (-p1 -p2)
      (if (region-active-p)
          (progn (setq -p1 (region-beginning))
                 (setq -p2 (region-end)))
        (progn (setq -p1 (line-beginning-position))
               (setq -p2 (line-end-position))))
      (with-temp-buffer (insert "\n") (append-to-register reg (point-min) (point-max)))
      (append-to-register reg -p1 -p2)
      (message "Appended to register %d: 「%s」." reg (buffer-substring-no-properties -p1 -p2))))


  (defun xah-clear-register (reg)
    "Clear register 1.
  See also: `xah-paste-from-register-1', `copy-to-register'.

  URL `http://ergoemacs.org/emacs/elisp_copy-paste_register_1.html'
  Version 2015-12-08"
    (interactive "p")
    (progn
      (copy-to-register reg (point-min) (point-min))
      (message "Cleared register %d." reg)))

#+END_SRC

#+RESULTS:
: xah-clear-register


#+BEGIN_SRC emacs-lisp

  (use-package helm-swoop
     :demand
    :config 
    (define-key helm-swoop-map [f11] 'xah-paste-from-register))
  (use-package helm-ag
     :demand
    :config 
  (define-key helm-ag-map [f11] 'xah-paste-from-register))
  (define-key helm-grep-map [f11] 'xah-paste-from-register)
#+END_SRC

#+RESULTS:
: xah-paste-from-register

** copy file path
   #+BEGIN_SRC emacs-lisp

(defun xah-copy-file-path (&optional @dir-path-only-p)
  "Copy the current buffer's file path or dired path to `kill-ring'.
Result is full path.
If `universal-argument' is called first, copy only the dir path.

If in dired, copy the file/dir cursor is on, or marked files.

If a buffer is not file and not dired, copy value of `default-directory' (which is usually the “current” dir when that buffer was created)

URL `http://ergoemacs.org/emacs/emacs_copy_file_path.html'
Version 2017-08-25"
  (interactive "P")
  (let (($fpath
         (if (equal major-mode 'dired-mode)
             (progn
               (mapconcat 'identity (dired-get-marked-files) "\n"))
           (if (buffer-file-name)
               (buffer-file-name)
             (expand-file-name default-directory)))))
    (kill-new
     (if @dir-path-only-p
         (progn
           (message "Directory path copied: 「%s」" (file-name-directory $fpath))
           (file-name-directory $fpath))
       (progn
         (message "File path copied: 「%s」" $fpath)
         $fpath )))))


(defun xah-copy-file-name (&optional @dir-path-only-p)
  "Copy the current buffer's file path or dired path to `kill-ring'.
Result is full path.
If `universal-argument' is called first, copy only the dir path.

If in dired, copy the file/dir cursor is on, or marked files.

If a buffer is not file and not dired, copy value of `default-directory' (which is usually the “current” dir when that buffer was created)

URL `http://ergoemacs.org/emacs/emacs_copy_file_path.html'
Version 2017-08-25"
  (interactive "P")
  (let (($fpath
         (if (equal major-mode 'dired-mode)
             (progn
               (mapconcat 'identity (mapcar #'file-name-nondirectory (dired-get-marked-files)) "\n"))
           (if (buffer-file-name)
               (buffer-file-name)
             (expand-file-name default-directory)))))
    (kill-new
     (if @dir-path-only-p
         (progn
           (message "Directory path copied: 「%s」" (file-name-directory $fpath))
           (file-name-directory $fpath))
       (progn
         (message "File path copied: 「%s」" $fpath)
         $fpath )))))

   #+END_SRC

   #+RESULTS:
   : xah-copy-file-name

** syntax color 

#+BEGIN_SRC emacs-lisp

(defun xah-syntax-color-hex ()
  "Syntax color text of the form 「#ff1100」 and 「#abc」 in current buffer.
URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
Version 2017-02-02"
  (interactive)
  (font-lock-add-keywords
   nil
   '(("#[ABCDEFabcdef[:digit:]]\\{3\\}"
      (0 (put-text-property
          (match-beginning 0)
          (match-end 0)
          'face (list :background
                      (let* (
                             (ms (match-string-no-properties 0))
                             (r (substring ms 1 2))
                             (g (substring ms 2 3))
                             (b (substring ms 3 4)))
                        (concat "#" r r g g b b))))))
     ("#[ABCDEFabcdef[:digit:]]\\{6\\}"
      (0 (put-text-property
          (match-beginning 0)
          (match-end 0)
          'face (list :background (match-string-no-properties 0)))))))
  (font-lock-flush))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defun xah-syntax-color-hsl ()
  "Syntax color CSS's HSL color spec eg 「hsl(0,90%,41%)」 in current buffer.
URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
Version 2017-02-02"
  (interactive)
  (require 'color)
  (font-lock-add-keywords
   nil
   '(("hsl( *\\([0-9]\\{1,3\\}\\) *, *\\([0-9]\\{1,3\\}\\)% *, *\\([0-9]\\{1,3\\}\\)% *)"
      (0 (put-text-property
          (+ (match-beginning 0) 3)
          (match-end 0)
          'face
          (list
           :background
           (concat
            "#"
            (mapconcat
             'identity
             (mapcar
              (lambda (x) (format "%02x" (round (* x 255))))
              (color-hsl-to-rgb
               (/ (string-to-number (match-string-no-properties 1)) 360.0)
               (/ (string-to-number (match-string-no-properties 2)) 100.0)
               (/ (string-to-number (match-string-no-properties 3)) 100.0)))
             "" )) ;  "#00aa00"
           ))))))
  (font-lock-flush))

(defun xah-css-insert-random-color-hsl ()
  "Insert a random color string of CSS HSL format.
Sample output: hsl(100,24%,82%);
URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
Version 2015-06-11"
  (interactive)
  (insert (format "hsl(%d,%d%%,%d%%);" (random 360) (random 100) (random 100))))
#+END_SRC
#+RESULTS:
: xah-syntax-color-hex


#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'css-mode-hook 'xah-syntax-color-hex)
(add-hook 'php-mode-hook 'xah-syntax-color-hex)
(add-hook 'html-mode-hook 'xah-syntax-color-hex)
#+END_SRC
** quote
   #+BEGIN_SRC emacs-lisp

     (defun xah-quote-lines ()
       "Change current text block's lines to quoted lines with comma or other separator char.
     When there is a text selection, act on the selection, else, act on a text block separated by blank lines.

     For example,

      cat
      dog
      cow

     becomes

      \"cat\",
      \"dog\",
      \"cow\",

     or

      (cat)
      (dog)
      (cow)

     If the delimiter is any left bracket, the end delimiter is automatically the matching bracket.

     URL `http://ergoemacs.org/emacs/emacs_quote_lines.html'
     Version 2017-01-08"
       (interactive)
       (let* (
              -p1
              -p2
              (-quoteToUse
               (read-string
                "Quote to use:" "\"" nil
                '(
                  ""
                  "\""
                  "'"
                  "("
                  "{"
                  "["
                  )))
              (-separator
               (read-string
                "line separator:" "," nil
                '(
                  ""
                  ","
                  ";"
                  )))
              (-beginQuote -quoteToUse)
              (-endQuote
               ;; if begin quote is a bracket, set end quote to the matching one. else, same as begin quote
               (let ((-syntableValue (aref (syntax-table) (string-to-char -beginQuote))))
                 (if (eq (car -syntableValue ) 4) ; ; syntax table, code 4 is open paren
                     (char-to-string (cdr -syntableValue))
                   -quoteToUse
                   ))))
         (if (use-region-p)
             (progn
               (setq -p1 (region-beginning))
               (setq -p2 (region-end)))
           (progn
             (if (re-search-backward "\n[ \t]*\n" nil "NOERROR")
                 (progn (re-search-forward "\n[ \t]*\n")
                        (setq -p1 (point)))
               (setq -p1 (point)))
             (re-search-forward "\n[ \t]*\n" nil "NOERROR")
             (skip-chars-backward " \t\n" )
             (setq -p2 (point))))
         (save-excursion
           (save-restriction
             (narrow-to-region -p1 -p2)
             (goto-char (point-min))
             (skip-chars-forward "\t ")
             (insert -beginQuote)
             (goto-char (point-max))
             (insert -endQuote)
             (goto-char (point-min))
             (while (re-search-forward "\n\\([\t ]*\\)" nil "NOERROR" )
               (replace-match
                (concat -endQuote -separator (concat "\n" (match-string 1)) -beginQuote) "FIXEDCASE" "LITERAL"))
             ;;
             ))))
   #+END_SRC

   #+RESULTS:
   : xah-quote-lines

** paste
#+BEGIN_SRC emacs-lisp

(defun xah-copy-to-register-1 ()
  "Copy current line or text selection to register 1.
See also: `xah-paste-from-register-1', `copy-to-register'.

URL `http://ergoemacs.org/emacs/elisp_copy-paste_register_1.html'
Version 2015-12-08"
  (interactive)
  (let (ξp1 ξp2)
    (if (region-active-p)
        (progn (setq ξp1 (region-beginning))
               (setq ξp2 (region-end)))
      (progn (setq ξp1 (line-beginning-position))
             (setq ξp2 (line-end-position))))
    (copy-to-register ?1 ξp1 ξp2)
    (message "copied to register 1: 「%s」." (buffer-substring-no-properties ξp1 ξp2))))



(defun xah-paste-from-register-1 ()
  "Paste text from register 1.
See also: `xah-copy-to-register-1', `insert-register'.
URL `http://ergoemacs.org/emacs/elisp_copy-paste_register_1.html'
Version 2015-12-08"
  (interactive)
  (when (use-region-p)
    (delete-region (region-beginning) (region-end)))
  (insert-register ?1 t))

#+END_SRC

** Emacs: Convert Image Files in Dired
By Xah Lee. Date: 2011-12-06. Last updated: 2016-07-19.

Here are commands to:

    Convert image file formats (jpg, png, gif),
    scale images (for example: 50% of original size)
    Auto-crop image's white border.
    Show / Remove image metadata.
    Zip Current Directory

These command work in dired, on current file or all marked files.
*** Process Image Core Function

Other commands call this function to do work.

#+BEGIN_SRC emacs-lisp
(defun xah-process-image (@file-list @args-str @new-name-suffix @new-name-file-suffix )
  "Wrapper to ImageMagick's “convert” shell command.
*file-list is a list of image file paths.
*args-str is argument string passed to ImageMagick's “convert” command.
*new-name-suffix is the string appended to file. e.g. “_new” gets you “…_new.jpg”
*new-name-file-suffix is the new file's file extension. e.g. “.png”

URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2015-10-19"
  (require 'dired)
  (mapc
   (lambda ($f)
     (let ( $newName $cmdStr )
       (setq $newName
             (concat
              (file-name-sans-extension $f)
              @new-name-suffix
              @new-name-file-suffix))
       (while (file-exists-p $newName)
         (setq $newName
               (concat
                (file-name-sans-extension $newName)
                @new-name-suffix
                (file-name-extension $newName t))))
       ;; relative paths used to get around Windows/Cygwin path remapping problem
       (setq $cmdStr
             (format
              "convert %s '%s' '%s'"
              @args-str
              (file-relative-name $f)
              (file-relative-name $newName)))
       (shell-command $cmdStr)))
   @file-list )
  (revert-buffer))
#+END_SRC
*** Scale Image

#+BEGIN_SRC emacs-lisp
(defun xah-dired-scale-image (@file-list @scale-percentage @sharpen?)
  "Create a scaled version of images of marked files in dired.
The new names have “-s” appended before the file name extension.

If `universal-argument' is called first, output is PNG format. Else, JPG.

When called in lisp code,
 *file-list is a list.
 *scale-percentage is a integer.
 *sharpen? is true or false.

Requires ImageMagick unix shell command.
URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2016-07-19"
  (interactive
   (let (
         ($fileList
          (cond
           ((string-equal major-mode "dired-mode") (dired-get-marked-files))
           ((string-equal major-mode "image-mode") (list (buffer-file-name)))
           (t (list (read-from-minibuffer "file name:"))))))
     (list $fileList
           (read-from-minibuffer "Scale %:")
           (y-or-n-p "Sharpen"))))
  (let ( ($outputSuffix (if current-prefix-arg ".png" ".jpg" )))
    (xah-process-image
     @file-list
     (format "-scale %s%% -quality 85%% %s " @scale-percentage (if @sharpen? "-sharpen 1" "" ))
     "-s" $outputSuffix )))
#+END_SRC
*** Auto-Crop Image

#+BEGIN_SRC emacs-lisp
(defun xah-image-autocrop ()
  "Create a new auto-cropped version of image.
If current buffer is jpg or png file, crop it.
If current buffer is dired, do the file under cursor or marked files.

The created file has “_crop638.” in the name, in the same dir.
It's in png or jpg, same as the original.

Requires ImageMagick shell command “convert”

If `universal-argument' is called first, output is PNG format. Else, JPG.
URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2017-08-27"
  (interactive)
  (let (
        ($bfName (buffer-file-name))
        $newName
        $cmdStr
        )
    (if (string-equal major-mode "dired-mode")
        (progn
          (let (($flist (dired-get-marked-files)))
            (mapc
             (lambda ($f)
               (setq $newName (concat (file-name-sans-extension $f) "_crop638." (file-name-extension $f)))
               (setq $cmdStr (format "convert -trim '%s' '%s'" (file-relative-name $f) (file-relative-name $newName)))
               (shell-command $cmdStr))
             $flist ))
          (revert-buffer))
      (progn
        (if $bfName
            (let (($ext (file-name-extension $bfName)))
              (if (and (not (string-equal $ext "jpg"))
                       (not (string-equal $ext "png")))
                  (user-error "not png or jpg at %s" $bfName)
                (progn
                  (setq $cmdStr
                        (format
                         "convert -trim '%s' '%s'"
                         $bfName
                         (concat (file-name-sans-extension $bfName) "_crop638." $ext)))
                  (shell-command  $cmdStr )
                  (message  $cmdStr))))
          (user-error "not img file or dired at %s" $bfName))))))
#+END_SRC
*** Convert to PNG

#+BEGIN_SRC emacs-lisp
(defun xah-dired-2png (@file-list)
  "Create a png version of images of marked files in dired.
Requires ImageMagick shell command.
URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2016-07-19"
  (interactive
   (let (
         ($fileList
          (cond
           ((string-equal major-mode "dired-mode") (dired-get-marked-files))
           ((string-equal major-mode "image-mode") (list (buffer-file-name)))
           (t (list (read-from-minibuffer "file name:"))))))
     (list $fileList)))
  (xah-process-image @file-list "" "-2" ".png" ))
#+END_SRC
*** Convert to JPG

#+BEGIN_SRC emacs-lisp
(defun xah-dired-2jpg (@file-list)
  "Create a JPG version of images of marked files in dired.
Requires ImageMagick shell command.
URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2016-07-19"
  (interactive
   (let (
         ($fileList
          (cond
           ((string-equal major-mode "dired-mode") (dired-get-marked-files))
           ((string-equal major-mode "image-mode") (list (buffer-file-name)))
           (t (list (read-from-minibuffer "file name:"))))))
     (list $fileList)))
  (xah-process-image @file-list "-quality 90%" "-2" ".jpg" ))
#+END_SRC
You can give them a key. 〔►see Emacs: How to Define Keys〕

To convert multiple images, mark them first in dired. 〔►see Emacs: File Manager, dired〕

For latest version, get it at https://github.com/xahlee/xah-fly-keys

see also ImageMagick Command Line Tutorial
*** Show/Remove Image Metadata

#+BEGIN_SRC emacs-lisp
(defun xah-dired-remove-all-metadata (@file-list)
  "Remove all metatata of buffer image file or marked files in dired.
 (typically image files)
URL `http://xahlee.info/img/metadata_in_image_files.html'
Requires exiftool shell command.

URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2016-07-19"
  (interactive
   (list
    (cond
     ((string-equal major-mode "dired-mode") (dired-get-marked-files))
     ((string-equal major-mode "image-mode") (list (buffer-file-name)))
     (t (list (read-from-minibuffer "file name:"))))))
  (if (y-or-n-p "Sure to remove all metadata?")
      (mapc
       (lambda ($f)
         (let ($cmdStr)
           (setq $cmdStr
                 (format "exiftool -all= -overwrite_original '%s'" (file-relative-name $f))) ; relative paths used to get around Windows/Cygwin path remapping problem
           (shell-command $cmdStr)))
       @file-list )
    nil
    ))

(defun xah-dired-show-metadata (@file-list)
  "Display metatata of buffer image file or marked files in dired.
 (typically image files)
URL `http://xahlee.info/img/metadata_in_image_files.html'
Requires exiftool shell command.
URL `http://ergoemacs.org/emacs/emacs_dired_convert_images.html'
Version 2016-07-19"
  (interactive
   (list
    (cond
     ((string-equal major-mode "dired-mode") (dired-get-marked-files))
     ((string-equal major-mode "image-mode") (list (buffer-file-name)))
     (t (list (read-from-minibuffer "file name:"))))))
  (mapc
   (lambda ($f)
     (shell-command
      (format "exiftool '%s'" (file-relative-name $f))
      ;; relative paths used to get around Windows/Cygwin path remapping problem
      ))
   @file-list ))
#+END_SRC

** url encoding 


*** Elisp: URL Percent Decode/Encode
By Xah Lee. Date: 2014-01-11. Last updated: 2015-09-14.

This page shows you how to percent decode/encode URI.

Examples of percent encoded URL:

    http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_%28D%C3%BCrer%29
    http://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8

Examples of decoded URL:

    http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_(Dürer)
    http://zh.wikipedia.org/wiki/文本编辑器

Decode URL

Here's solution.

#+BEGIN_SRC emacs-lisp
(defun xah-html-decode-percent-encoded-url ()
  "Decode percent encoded URI of URI under cursor or selection.

Example:
    http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_%28D%C3%BCrer%29
becomes
    http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_(Dürer)

Example:
    http://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8
becomes
    http://zh.wikipedia.org/wiki/文本编辑器

For string version, see `xah-html-url-percent-decode-string'.
To encode, see `xah-html-encode-percent-encoded-url'.
URL `http://ergoemacs.org/emacs/elisp_decode_uri_percent_encoding.html'
Version 2015-09-14."
  (interactive)
  (let ($boundaries $p1 $p2 $input-str)
    (if (use-region-p)
        (progn
          (setq $p1 (region-beginning))
          (setq $p2 (region-end)))
      (progn
        (setq $boundaries (bounds-of-thing-at-point 'url))
        (setq $p1 (car $boundaries))
        (setq $p2 (cdr $boundaries))))
    (setq $input-str (buffer-substring-no-properties $p1 $p2))
    (require 'url-util)
    (delete-region $p1 $p2)
    (insert (decode-coding-string (url-unhex-string $input-str) 'utf-8))))
#+END_SRC
2014-04-27 thanks nns for the solution.
Encode URL

To encode, you can just use this:

(require 'url-util)
 (url-encode-url $input-str)

Here's a command version:

#+BEGIN_SRC emacs-lisp
(defun xah-html-encode-percent-encoded-url ()
  "Percent encode URL under cursor or selection.

Example:
    http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_(Dürer)
becomes
    http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_(D%C3%BCrer)

Example:
    http://zh.wikipedia.org/wiki/文本编辑器
becomes
    http://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8

URL `http://ergoemacs.org/emacs/elisp_decode_uri_percent_encoding.html'
Version 2015-09-14."
  (interactive)
  (let ($boundaries $p1 $p2 $input-str)
    (if (use-region-p)
        (progn
          (setq $p1 (region-beginning))
          (setq $p2 (region-end)))
      (progn
        (setq $boundaries (bounds-of-thing-at-point 'url))
        (setq $p1 (car $boundaries))
        (setq $p2 (cdr $boundaries))))
    (setq $input-str (buffer-substring-no-properties $p1 $p2))
    (require 'url-util)
    (delete-region $p1 $p2)
    (insert (url-encode-url $input-str))))
#+END_SRC
*** Emacs Lisp URL Percent Encode/Decode Functions

Emacs has a bundled library url-util for handling URL.

The main functions for manipulating URL are:

    url-unhex-string → decode URL percent encoded string. For example: %20 ⇒  .
    url-hexify-string → encode string into URL percent encoded string, for example,  ⇒ %20.
    url-encode-url → like url-hexify-string, but leave URL's protocol part and domain etc parts intact.

and decode-coding-string from emacs lisp itself.

Here's examples of using them.

url-hexify-string will turn a string into URL percent encoded string, including slash or colon characters used in URL such as http://.

(require 'url-util)

(url-hexify-string "'(),/\"" )
;; "%27%28%29%2C%2F%22"

(url-hexify-string "文本编辑器") ; Chinese
;; "%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"

(url-hexify-string "http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_(Dürer)" )
;; "http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSaint_Jerome_in_His_Study_%28D%C3%BCrer%29"

To decode a hexified string, use url-unhex-string then decode-coding-string. Example:

(require 'url-util)

(url-hexify-string "http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_(Dürer)" )
;; "http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSaint_Jerome_in_His_Study_%28D%C3%BCrer%29"

(decode-coding-string
 (url-unhex-string
  "http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSaint_Jerome_in_His_Study_%28D%C3%BCrer%29")
 'utf-8)
;; "http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_(Dürer)"

(url-hexify-string "文本编辑器")
;; "%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"

(decode-coding-string
 (url-unhex-string "%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8" ) 'utf-8)
;; "文本编辑器"

To encode a full URL, use url-unhex-string then decode-coding-string. Example:

(require 'url-util)

(url-encode-url "http://zh.wikipedia.org/wiki/文本编辑器")
;; "http://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"

(url-encode-url "http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_(Dürer)")
;; "http://en.wikipedia.org/wiki/Saint_Jerome_in_His_Study_(D%C3%BCrer)"

Elisp + JavaScript Solution

Here's a solution by calling a external node.js script. Elisp: Calling External Command to Decode URL Percent Encoding.

** date insert
   #+BEGIN_SRC emacs-lisp
     (require 'ido) ; part of emacs

     (defun xah-insert-date ()
       "Insert current date and or time.
     Insert date in this format: yyyy-mm-dd.
     When called with `universal-argument', prompt for a format to use.
     If there's text selection, delete it first.

     Do not use this function in lisp code. Call `format-time-string' directly.

     URL `http://ergoemacs.org/emacs/elisp_insert-date-time.html'
     version 2016-12-18"
       (interactive)
       (when (use-region-p) (delete-region (region-beginning) (region-end)))
       (let (($style
              (if current-prefix-arg
                  (string-to-number
                   (substring
                    (ido-completing-read
                     "Style:"
                     '(
                       "1 → 2016-10-10 Monday"
                       "2 → 2016-10-10T19:39:47-07:00"
                       "3 → 2016-10-10 19:39:58-07:00"
                       "4 → Monday, October 10, 2016"
                       "5 → Mon, Oct 10, 2016"
                       "6 → October 10, 2016"
                       "7 → Oct 10, 2016"
                       )) 0 1))
                0
                )))
         (insert
          (cond
           ((= $style 0)
            (format-time-string "%Y-%m-%d") ; "2016-10-10"
            )
           ((= $style 1)
            (format-time-string "%Y-%m-%d %A") ; "2016-10-10 Monday"
            )
           ((= $style 2)
            (concat
             (format-time-string "%Y-%m-%dT%T")
             (funcall (lambda ($x) (format "%s:%s" (substring $x 0 3) (substring $x 3 5))) (format-time-string "%z")))
            ;; eg "2016-10-10T19:02:23-07:00"
            )
           ((= $style 3)
            (concat
             (format-time-string "%Y-%m-%d %T")
             (funcall (lambda ($x) (format "%s:%s" (substring $x 0 3) (substring $x 3 5))) (format-time-string "%z")))
            ;; eg "2016-10-10 19:10:09-07:00"
            )
           ((= $style 4)
            (format-time-string "%A, %B %d, %Y")
            ;; eg "Monday, October 10, 2016"
            )
           ((= $style 5)
            (format-time-string "%a, %b %d, %Y")
            ;; eg "Mon, Oct 10, 2016"
            )
           ((= $style 6)
            (format-time-string "%B %d, %Y")
            ;; eg "October 10, 2016"
            )
           ((= $style 7)
            (format-time-string "%b %d, %Y")
            ;; eg "Oct 10, 2016"
            )
           (t
            (format-time-string "%Y-%m-%d"))))))
   #+END_SRC

   #+RESULTS:
   : xah-insert-date
** space-newline

   #+begin_src emacs-lisp
     (defun xah-space-to-newline ()
       "Replace space sequence to a newline char.
     Works on current block or selection.

     URL `http://ergoemacs.org/emacs/emacs_space_to_newline.html'
     Version 2017-08-19"
       (interactive)
       (let* ( $p1 $p2 )
         (if (use-region-p)
             (progn
               (setq $p1 (region-beginning))
               (setq $p2 (region-end)))
           (save-excursion
             (if (re-search-backward "\n[ \t]*\n" nil "move")
                 (progn (re-search-forward "\n[ \t]*\n")
                        (setq $p1 (point)))
               (setq $p1 (point)))
             (re-search-forward "\n[ \t]*\n" nil "move")
             (skip-chars-backward " \t\n" )
             (setq $p2 (point))))
         (save-excursion
           (save-restriction
             (narrow-to-region $p1 $p2)
             (goto-char (point-min))
             (while (re-search-forward " +" nil t)
               (replace-match "\n" ))))))
   #+end_src
