# -*- coding: utf-8; -*-


* header
#+BEGIN_SRC emacs-lisp
;; -*-mode: emacs-lisp ;  coding: utf-8; buffer-read-only: t;  -*-

#+END_SRC
* python 


** debug & help
   #+BEGIN_SRC emacs-lisp


   ;; python -i 은 입출력에 버퍼링이 없도록 합니다.
   (setq gud-pdb-command-name "python -i -m pdb" )

   ;;autocomplete;;(require 'ein)
   ;;autocomplete;;(autoload 'jedi:setup "jedi" nil t)
   ;;autocomplete;;(add-hook 'python-mode-hook 'jedi:setup)
   ;;autocomplete;;(add-hook 'python-mode-hook 'jedi:ac-setup)
   ;;autocomplete;;(setq jedi:setup-keys t)

   (defun python-help (w)
     "Launch PyDOC on the Word at Point"
     (interactive
      (let ((symbol (with-syntax-table py-otted-expression-syntax-table
              (current-word)))
        (enable-recursive-minibuffers t))
        (list (read-string (if symbol
                   (format "Describe symbol (default %s): " symbol)
                 "Describe symbol: ")
               nil nil symbol))))
     (process-send-string (get-process py-which-bufname) "help(" w ")\n"))
   #+END_SRC

*** lookup :deprecated:
    deprecated by spacemacs
    #+BEGIN_SRC emacs-lisp :tangle no


    ;; START PYLOOKUP
    ; add pylookup to your loadpath, ex) "~/.lisp/addons/pylookup"
    (setq pylookup-dir "c:/usr/local/editor/emacsW32/pylookup/")
    ;;(add-to-list 'load-path pylookup-dir)
    ;; load pylookup when compile time

    (eval-when-compile (require 'pylookup))
    ;; set executable file and db file
    (setq pylookup-program (concat pylookup-dir "/pylookup.bat"))
    (setq pylookup-db-file (concat pylookup-dir "/pylookup.db"))

    ;; to speedup, just load it on demand
    (autoload 'pylookup-lookup "pylookup"
      "Lookup SEARCH-TERM in the Python HTML indexes." t)
    (autoload 'pylookup-update "pylookup" 
      "Run pylookup-update and create the database at `pylookup-db-file'." t)


    (global-set-key "\C-h;" 'pylookup-lookup)
    ;; EMD PYLOOKUP

    #+END_SRC

** outline

   #+BEGIN_SRC emacs-lisp
     ;;(leaf imenu-tree )

     ;;; _OUTLINE 
     (leaf outline-magic
       :ensure t
       :config
       (general-define-key
        :keymaps 'outline-minor-mode-map
        [S-tab] 'outline-cycle
        [(backtab)]'outline-cycle))

     ;; (leaf outshine
     ;;   :config
     ;;   (add-hook  'outline-minor-mode-hook 'outshine-hook-function))
     ;; 문서형 프로그래밍에 유리 
     ;;(leaf python-magic)


     ;; python-magic 참고
     (add-hook 
      'python-mode-hook 
      (lambda ()
        ;;(setq outline-regexp "[ \t]*# \\|[ \t]+\\(class\\|def\\|if\\|elif\\|else\\|while\\|for\\|try\\|except\\|with\\) ")
        ;;(setq outline-regexp "def\\|class ")
        (setq outline-regexp "[ \t]*\\(class\\|def\\|with\\|for\\|@.*\\|###_.*\\) ")
        (setq outline-heading-end-regexp "\n")
        (setq 
         outline-level 
         (lambda ()
           (let (buffer-invisibility-spec)
             (save-excursion
               (skip-chars-forward " \t")         
               (if (char-equal ?\# (char-after))
                   (current-column)
                 (+ (current-column) 1)
                 )))))
        ;; (smartparens-mode) 
        (outline-minor-mode t)
        ;; (set (make-local-variable 'eldoc-documentation-function) 'rope-eldoc-function)
        ;;deprecated;;(set (make-variable-buffer-local 'beginning-of-defun-function)
        ;;deprecated;;     'py-beginning-of-def-or-class)

        ;; (add-hook 'which-func-functions #'python-info-current-defun-short nil t)

        ;; (guide-key/add-local-guide-key-sequence "C-c")


        ;;(hide-body)
        ;;(show-body)
        ;;(define-key outline-minor-mode-map [tab]    'outline-cycle)
        ;;(define-key outline-minor-mode-map [S-tab]  'indent-for-tab-command)
        ;;(define-key outline-minor-mode-map [M-down] 'outline-move-subtree-down)
        ;;(define-key outline-minor-mode-map [M-up]   'outline-move-subtree-up)
        ;;(define-key outline-minor-mode-map [S-tab]    'outline-cycle)
     ;; If you used python-mode.el you probably will miss auto-indentation
     ;; when inserting newlines.  To achieve the same behavior you have
     ;; two options:
     ;; 1) Use GNU/Emacs' standard binding for `newline-and-indent': C-j.
     ;; 2) Add the following hook in your .emacs:
     ;; (add-hook 'python-mode-hook
     ;;   #'(lambda ()
     ;;       (define-key python-mode-map "\C-m" 'newline-and-indent)))
        ))

     (add-hook 'python-mode-hook 'evil-text-object-python-add-bindings)

     ;;deprecated;;(require 'python-mode)
     ;;deprecated;;(require 'ipython)
     ;;deprecated;;(py-set-ipython-completion-command-string "ipython.exe")
     ;;deprecated;;(set-default
     ;;deprecated;; 'py-python-command-args
     ;;deprecated;; '("-u" "c:/usr/local/python27/Scripts/ipython-script.py"  "--colors=NoColor"))



   #+END_SRC


** rope                                                         :deprecated:
   #+BEGIN_SRC emacs-lisp :tangle no

(defvar disable-python-trace nil)

;; http://www.emacswiki.org/emacs/ElDoc
(defun rope-eldoc-function ()
  (interactive)
  (let* ((win-conf (current-window-configuration))
         (resize-mini-windows nil)
         (disable-python-trace t)
         class fun args result-type
         (flymake-message (python-flymake-show-help))
         (initial-point (point))
         (paren-range (let (tmp)
                        (ignore-errors
                          (setq tmp (vimpulse-paren-range 0 ?\( nil t))
                          (if (and tmp (>= (point) (car tmp)) (<= (point) (cadr tmp)))
                              tmp
                            nil))))
         (result (save-excursion
                   ;; check if we on the border of args list - lparen or rparen
                   (if paren-range
                       (goto-char (car paren-range)))
                   (call-interactively 'rope-show-doc)
                   (set-buffer "*rope-pydoc*")
                   (goto-char (point-min))
                   (if (or (equal (point-max) 1)
                           (not (re-search-forward "\\([a-zA-Z_]+[a-zA-Z0-9_]*\\)(.*):" (point-at-eol) t))
                           (and (current-message) (string-match-p "BadIdentifierError" (current-message))))
                       nil
                     (let (result)
                       ;; check if this is class definition
                       (if (looking-at "class \\([a-zA-Z_]+[a-zA-Z0-9_]*\\)(.*):")
                           (progn
                             (goto-char (point-at-eol))
                             (re-search-forward (buffer-substring (match-beginning 1) (match-end 1)))))
                       (goto-char (point-at-bol))
                       (setq result (buffer-substring (point) (point-at-eol)))

                       ;; check if exist better description of function
                       (goto-char (point-at-eol))
                       (string-match "\\([a-zA-Z_]+[a-zA-Z0-9_]*\\)(.*)" result) ;get function name
                       (if (re-search-forward (concat (match-string 1 result) "(.*)") nil t)
                           (progn
                             (goto-char (point-at-bol))
                             (setq result (buffer-substring (point) (point-at-eol)))))

                       ;; return result
                       result
                       ))))
         (arg-position (save-excursion
                         (if paren-range
                             (count-matches "," (car paren-range) (point))))))
    ;; save window configuration
    (set-window-configuration win-conf)
    ;; process main result
    (if result
        (progn
          (setq result-type (nth 1 (split-string result "->")))
          (setq result (nth 0 (split-string result "->")))
          (setq result (split-string result "("))
          (setq fun (nth 1 (split-string (nth 0 result) "\\.")))
          (setq class (nth 0 (split-string (nth 0 result) "\\.")))
          ;; process args - highlight current function argument
          (setq args (nth 0 (split-string (nth 1 result) ")")))

          ;; highlight current argument
          (if args
              (progn
                (setq args (split-string args ","))
                (setq args (let ((num -1))
                             (mapconcat
                              (lambda(x)(progn
                                          (setq num (+ 1 num))
                                          (if (equal num arg-position) (propertize x 'face 'eldoc-highlight-function-argument) x)))
                              args
                              ",")))))

          ;; create string for type signature
          (setq result
                (concat
                 (propertize "Signature: " 'face 'flymake-message-face)

                 (if fun
                     (concat (propertize (org-trim class) 'face 'font-lock-type-face)
                             "."
                             (propertize (org-trim fun) 'face 'font-lock-function-name-face))
                   (propertize (org-trim class) 'face 'font-lock-function-name-face))

                 " (" args ")"

                 (if result-type
                     (concat " -> " (org-trim result-type)))
                 ))))

    ;; create final result
    (if (and (null flymake-message) (null result))
        nil
      (concat flymake-message
              (if (and result flymake-message) "\n")
              result))))



  (defadvice message(around message-disable-python-trace activate)
    (if disable-python-trace
        t
      ad-do-it))

   #+END_SRC

   #+RESULTS:
   : message


