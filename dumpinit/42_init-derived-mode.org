;; -*- coding: utf-8; -*-
;;; http://ergoemacs.org/emacs/elisp_syntax_coloring.html
;;; my own mode 
* header
#+BEGIN_SRC emacs-lisp 
;; -*- coding: utf-8; -*-
#+END_SRC

* qac mode 
#+BEGIN_SRC emacs-lisp
(define-derived-mode qac-mode compilation-mode "qac"
  "Major mode for editing Octave code.

Octave is a high-level language, primarily intended for numerical
computations.  It provides a convenient command line interface
for solving linear and nonlinear problems numerically.  Function
definitions can also be stored in files and used in batch mode."
  ;; grep-regexp-alist 
  ;; compilation-error-regexp-alist
  ;; 위의 두 변수를 수정하여 새로은 컴파일모드를 생성할 수 있다. 
  (message "qac mode")
  )
#+END_SRC

* ELF MODE 
[[http://oremacs.com/2016/08/28/elf-mode/][elf-mode - view the symbol list in a binary · (or emacs]]

#+BEGIN_SRC emacs-lisp
(leaf elf-mode :require t)
#+END_SRC

#+RESULTS:

* TNNL FILE


  #+BEGIN_SRC emacs-lisp
    (define-derived-mode mo-mode outline-mode "mo"
      "Major mode for editing Octave code.

    Octave is a high-level language, primarily intended for numerical
    computations.  It provides a convenient command line interface
    for solving linear and nonlinear problems numerically.  Function
    definitions can also be stored in files and used in batch mode."
      ;; grep-regexp-alist 
      ;; compilation-error-regexp-alist
      ;; 위의 두 변수를 수정하여 새로은 컴파일모드를 생성할 수 있다. 
      (setq outline-regexp "[ \t]*\\(SPECIFICATION\\|SERVICE\\|GROUP\\|OBJECT\\|COLUMNS\\|RESOURCES\\|LAYOUT\\)")
      (setq outline-heading-end-regexp "\n")
      (setq 
       outline-level 
       (lambda ()
         (save-excursion

           (skip-chars-forward " \t")                          
           (cond ((looking-at "SPECIFICATION") 1) 
                 ((looking-at "SERVICE") 2) 
                 ((looking-at "GROUP") 3) 
                 ((looking-at "OBJECT") 4) 
                 ((looking-at "COLUMNS") 5) 
                 ((looking-at "RESOURCES") 6) 
                 ((looking-at "LAYOUT") 6) 
                 (t 0))))))

    (define-derived-mode uimx-mode outline-mode "uimx"
      "Major mode for editing Octave code.

    Octave is a high-level language, primarily intended for numerical
    computations.  It provides a convenient command line interface
    for solving linear and nonlinear problems numerically.  Function
    definitions can also be stored in files and used in batch mode."
      ;; grep-regexp-alist 
      ;; compilation-error-regexp-alist
      ;; 위의 두 변수를 수정하여 새로은 컴파일모드를 생성할 수 있다. 
      (setq outline-regexp "[ \t]*\*.*\.class:")
      (setq outline-heading-end-regexp "\n")
      (setq 
       outline-level 
       (lambda ()
         (save-excursion
           (skip-chars-forward " \t")                          
           (cond 
                 (t 1))))))

  #+END_SRC

  #+RESULTS:
  : mo-mode


* outline helper function
#+begin_src  emacs-lisp
(defun outline-copy-visible (keepp)
  "Create a copy of the visible part of the current buffer and add
it to the kill ring so it can be copied into other buffers or programs.
The copy is created in a temporary buffer and removed after use.
As a special case, if you have a prefix arg KEEPP, the temporary
buffer will not be removed but presented to you so that you can
continue to use it.
This function is derived from org-export-visible."
  (interactive "P")
  (let* ((file buffer-file-name)
	 (buffer (get-buffer-create "*Outline Yank Visible*"))
	 s e)
    (with-current-buffer buffer (erase-buffer))
    (save-excursion
      (setq s (goto-char (point-min)))
      (while (not (= (point) (point-max)))
	(goto-char (outline-find-invisible))
	(append-to-buffer buffer s (point))
	(setq s (goto-char (outline-find-visible))))
      (goto-char (point-min))
      (set-buffer buffer)
      (kill-new (buffer-substring (point-min) (point-max)))
    (if (not keepp)
	(kill-buffer buffer)
      (switch-to-buffer-other-window buffer)
      (goto-char (point-min))))))

(defun outline-find-visible ()
  (let ((s (point)))
    (while (and (not (= (point-max) (setq s (next-overlay-change s))))
		(get-char-property s 'invisible)))
    s))

(defun outline-find-invisible ()
  (let ((s (point)))
    (while (and (not (= (point-max) (setq s (next-overlay-change s))))
		(not (get-char-property s 'invisible))))
    s))


#+end_src

#+RESULTS:
: outline-find-invisible

* emacs patch
** scroll all mode
   #+begin_src emacs-lisp
     (defun scroll-all-function-all (func arg)
       "Apply function FUNC with argument ARG to all visible windows."
       (let ((num-windows (count-windows))
             (count 1))
         (when (> num-windows 1)
           (other-window 1)
           (while (< count num-windows)
             (condition-case nil
                 (funcall func arg)
               (error nil))
             (ccm-position-cursor)
             (global-hl-line-highlight)
             (other-window 1)
             (setq count (1+ count))))))
   #+end_src

   #+RESULTS:
   : scroll-all-function-all
  

