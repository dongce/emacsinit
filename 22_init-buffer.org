# -*- coding: utf-8; -*-
* header
#+BEGIN_SRC emacs-lisp
;; -*-mode: emacs-lisp; coding: utf-8; buffer-read-only: t;-*-
#+END_SRC


* buffer 
** util-function
 #+BEGIN_SRC emacs-lisp
   ;;(require 'dired+)
   (require 'filecache)

   ;;(setq bookmark-default-file "~/bookmarks")

   ;; 윈도우 쪼개지는 방향을 결정합니다.
   ;; 다음을 이용하여 쪼개지는 방향이 가로입니다. 
   (setf split-width-threshold 20480 )


   ;;deprecated;;(open-sln "c:/ffx/CFCS/DLP_LINK11/proj/winproj/winproj.sln")
   ;;deprecated;;(open-sln "c:/ffx/CFCS/DLP_ISDL/proj/winproj/winproj.sln")
   ;;deprecated;;(open-sln "c:/ffx/CFCS/SIGCONV/proj/winproj/winproj.sln")
   ;;(global-set-key (kbd "<C-tab>") 'iflipb-next-buffer)
   ;;(require 'iflipb)
   ;;;;(global-set-key (kbd "M-n") 'iflipb-next-buffer)
   ;;;;(global-set-key (kbd "M-N") 'iflipb-previous-buffer)
   ;;deprecated;;(require 'cycle-buffer)
   ;;deprecated;;(global-set-key (kbd "<C-tab>") 'cycle-buffer)
   ;;(require 'swbuff)
   ;;(global-set-key (kbd "<C-tab>") 'swbuff-switch-to-next-buffer)
   ;;(global-set-key (kbd "<C-tab>") 'bs-cycle-next)

   ;;(require 'cycbuf)
   ;;(global-set-key (kbd "<C-tab>") '(aif  (cycbuf-switch-to-next-buffer)))

   ;;(require 'tabbar)
   ;;(tabbar-mode)

   (global-set-key "\C-b" 'switch-to-buffer )


   (defun dir-personal ()
     (interactive)
     (dired "w:/dongil"))

   (defun dir-date ()
     (interactive)
     (dired "g:/svndir/정리/"))

   (defun dir-add ()
     (interactive)
     (dired "//10.239.12.87/system psr/FFX/SW/SW구조설계자료/FFX_SW구조설계_20090220/"))

   (defun dir-ffx ()
     (interactive)
     (dired "\\10.239.12.38\ffx-i\FFX\FFX 산출물 Data"))

   (defun dir-guile ()
     (interactive)
     (dired "c:/usr/local/guile/site-guile/"))

   (defun dirf()
     (interactive)
     (dired "c:/ffx/cfcs")) 

   (defun dir-desktop()
     (interactive)
     (dired "c:/Documents and Settings/dongil/바탕 화면/")) 


   (defun download ()
     (interactive)
     (dired "h:/FIREFOX"))

   (defun switch-to-buffer-and-back (buf)
     "Toggle between given buffer and the current buffer."
     (interactive)
     (if (equal (buffer-name) buf)
         (bury-buffer)
       (switch-to-buffer buf 'NORECORD)))


   ;;(global-set-key [(control c) ?l] (aif (switch-to-buffer-and-back "BUFFER-NAME-HERE")))
   ;;(global-set-key [(hyper s)] (aif (switch-to-buffer-and-back "BUFFER-NAME-HERE")))

   ;; (global-set-key [(control ?\')]     'recentf-open-most-recent-file)
   ;; (global-set-key [(control ?\")]     'recentf-open-files)

   (use-package recentf-ext)
   (use-package open-junk-file)

   ;; (define-key dired-mode-map "V" 
   ;;   (aif (mapcar (lambda (x) (find-file-other-frame x )) (dired-get-marked-files))))


   ;;(define-key dired-mode-map "V" 
   ;;  (aif (mapcar (lambda (x) (find-file-other-window x )) (dired-get-marked-files)) (balance-windows)))


   (define-key dired-mode-map "V" 
     (aif (mapcar (lambda (x)
                    (let ((find-file-hook nil))
                      (find-file-noselect x )))
                  (dired-get-marked-files)) ))

   ;; https://plus.google.com/113859563190964307534/posts
   ;; dired 관련 사항 

   (setq dired-dwim-target t)


   ;;NORECURSIVE;;(setq dired-recursive-copies (quote always))
   ;;NORECURSIVE;;(setq dired-recursive-deletes (quote top))


   ;;WHATCHAR;;you can find out the decimal/hex/name of a unicode char by calling “describe-char”.
   ;;WHATCHAR;;Or call “what-cursor-position” with a universal argument. e.g. type: 【ctrl+u ctrl+x =】.
   ;;WHATCHAR;;better is just to assign a key to “describe-char”. I use 【Ctrl+h c】.

   ;; 윈도우 숫자를 부여 
   ;; (require 'window-numbering)
   ;; (window-numbering-mode 1)


   (defun next-user-buffer ()
     "Switch to the next user buffer.
   User buffers are those whose name does not start with *."
     (interactive)
     (next-buffer)
     (let ((i 0))
       (while (and (string-match "^*" (buffer-name)) (< i 50))
         (setq i (1+ i)) (next-buffer) )))

   (defun previous-user-buffer ()
     "Switch to the previous user buffer.
   User buffers are those whose name does not start with *."
     (interactive)
     (previous-buffer)
     (let ((i 0))
       (while (and (string-match "^*" (buffer-name)) (< i 50))
         (setq i (1+ i)) (previous-buffer) )))

   (defun next-emacs-buffer ()
     "Switch to the next emacs buffer.
   Emacs buffers are those whose name starts with *."
     (interactive)
     (next-buffer)
     (let ((i 0))
       (while (and (not (string-match "^*" (buffer-name))) (< i 50))
         (setq i (1+ i)) (next-buffer) )))

   (defun previous-emacs-buffer ()
     "Switch to the previous emacs buffer.
   Emacs buffers are those whose name starts with *."
     (interactive)
     (previous-buffer)
     (let ((i 0))
       (while (and (not (string-match "^*" (buffer-name))) (< i 50))
         (setq i (1+ i)) (previous-buffer) )))

   (require 'buffer-utils)

   ;;; most-positive-fixnum
   ;; (require 'vlf)


   ;; (use-package smartwin :config (smartwin-mode 1))


   ;; (use-package resize-window)

   ;; (use-package ivy)

 #+END_SRC

 #+RESULTS:
 : buffer-utils


** ibuffer                                                       :deprecated:
#+BEGIN_SRC emacs-lisp :tangle no

  (global-set-key "\C-f" 'ibuffer )

  (require 'ibuf-ext)
  (add-to-list 'ibuffer-never-show-predicates "^\\*Pymacs\\*")

  (setq 
   ibuffer-saved-filter-groups
   '(("default"
      ("북마크"   (or
                   (mode   . bookmark-edit-annotation-mode)
                   (name   . "^\\*Bookmark Annotation.*")
                   (name   . "^\\*Bookmark List\\*$")
                   (name   . "^\\*bm-bookmarks\\*$")))
      ("디렉토리" (mode   . dired-mode))
      ("파이썬" (or
                 (mode     . python-mode)
                 (name . "^\\*Python\\*$")))
      ("랩소디" (or
                 (name . "\\.sbs$")
                 (name . "\\.rpw$")))
      ("형상관리" (or
                   (mode . dvc-diff)
                   (name . "^\\*dvc")
                   (name . "^\\*svn")
                   (name . "^\\*git")
                   (name . "^\\*magit")
                   (name . "^\\*bzr")))
      ("C/C++" (or
                (mode     . c++-mode)
                (mode     . c-mode)
                (mode     . idl-mode)
                (mode     . cc-mode)))
      ("프로젝트" (mode   . project-buffer-mode))
      ("ORG"   (or
                (name . "^\\*Calendar\\*$")
                (name . "^\\*Remember\\*$")
                (mode . org-mode)))
      ("텍스트" (or
                 (mode   . text-mode)))
      ("배치파일" (or
                   (mode   . dos-mode)))
      ("이멕스" (or
                 (mode   . emacs-lisp-mode)
                 (name . "^\\*scratch\\*$")
                 (name . "^\\*Messages\\*$")))
      ("scheme" (or 
                 (mode   . scheme-mode)
                 (name   . "^\\*scheme\\*$")))
      ("SQL" (or 
              (mode   . sql-mode)
              (name   . "^\\*SQL\\*$")))
      ("이메일"  (or
                  (mode . mu4e-main-mode )
                  (mode . mu4e-view-mode )
                  (mode . mu4e-headers-mode)))
      ("컴파일" (or
                 (mode   . grep-mode)
                 (mode   . occur-mode)
                 (mode   . compilation-mode)))
      )))

  (add-hook 'ibuffer-hook
            (lambda ()
              ;; (ibuffer-projectile-set-filter-groups)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic))))
#+END_SRC

* project
#+BEGIN_SRC emacs-lisp
  (use-package fuzzy)
  (use-package project-buffer-mode
    :config
    (require 'project-buffer-mode+)
    (project-buffer-mode-p-setup)
    (require 'project-buffer-occur)
    (define-key project-buffer-mode-map [(?O)] 'project-buffer-occur))

  ;;(autoload 'find-sln "sln-mode" "" t)

  (require 'sln-mode )

  ;; 함수를 재정의 합니다. 
  (defun sln-action-handler-2005 (action project-name project-path platform configuration)
    (let ((sln-cmd (cond ((eq action 'build) "")
                         ((eq action 'clean) "/clean")
                         ((eq action 'run)   "")
                         ((eq action 'debug) ""))))
      (when (or (not (eq action 'clean))
                (funcall project-buffer-confirm-function (format "Clean the project %s " project-name)))
        (compile (format "vcbuild /platform:%s %s %s" platform sln-cmd project-path)))))


  (defun open-sln (f)
    (if (file-exists-p f )  (find-sln f )))

  ;;(require 'project-persist)

  (require 'iproject)
  (iproject-key-binding)

  (require 'fsproject)

  (defun make-action-handler(action project-name project-path platform configuration)
    "project action handler."
    (let ((make-cmd (cond ((eq action 'build) "")
                          ((eq action 'clean) "clean")
                          ((eq action 'run)   "run")
                          ((eq action 'debug) "debug"))))
      (compile 
       (concat "make -j16 -C " (file-name-directory project-path) 
               " -f " (file-name-nondirectory project-path) 
               " " make-cmd))))

  ;;(autoload 'fsproject-create-project "fsproject")
  ;;(defun fsproject-new(root-folder)
  ;;  (interactive "sRoot folder: ")
  ;;  (let ((regexp-project-name  "[Mm]akefile")
  ;;        (regexp-file-filter   '("\\.cpp$" "\\.h$" "\\.inl$" "\\.mak$" "Makefile"))
  ;;        (ignore-folders       '("build" "docs" "bin"))
  ;;        (pattern-modifier     nil)
  ;;        (build-configurations '("debug" "release"))
  ;;        (platforms            '("Linux")))
  ;;    (fsproject-create-project root-folder
  ;;                              regexp-project-name
  ;;                              regexp-file-filter
  ;;                              'make-action-handler
  ;;                              ignore-folders
  ;;                              pattern-modifier
  ;;                              build-configurations
  ;;                              platforms)))
  ;;


  ;;(autoload 'fsproject-create-project "fsproject")
  (defun fsproject-new(root-folder)
    (interactive "sRoot folder: ")
    (let ((regexp-project-name  "[Mm]akefile")
          (regexp-file-filter   '("\\.cpp$" "\\.h$" "\\.inl$" "\\.mak$" "Makefile"))
          (ignore-folders       '("build" "docs" "bin"))
          (pattern-modifier     '(("^\\(?:.*/\\)?\\([a-zA-Z0-9_]*\\.cpp\\)$" . "source/\\1")
                                  ("^\\(?:.*/\\)?\\([a-zA-Z0-9_]*\\.\\(?:h\\|inl\\)\\)$" . "include/\\1")))
          (build-configurations '("debug" "release"))
          (platforms            '("Linux")))
      (fsproject-create-project root-folder
                                regexp-project-name
                                regexp-file-filter
                                'make-action-handler
                                ignore-folders
                                pattern-modifier
                                build-configurations
                                platforms)))
  (with-package*
    (projectile)
    (defun projectile-serialize (data filename)
      "Serialize DATA to FILENAME.

  The saved data can be restored with `projectile-unserialize'."
      (when (file-writable-p filename)
        (with-temp-file filename
          (set-buffer-file-coding-system 'utf-8) ;계속 물어봐서 고정하였음. 
          (insert (let (print-length) (prin1-to-string data))))))

    (defun projectile-unserialize (filename)
      "Read data serialized by `projectile-serialize' from FILENAME."
      (when (file-exists-p filename)
        (with-temp-buffer
          (set-buffer-file-coding-system 'utf-8) ;계속 물어봐서 고정하였음. 
          (insert-file-contents filename)
          (read (buffer-string))))))


  ;; check following

  (use-package projectile
    :config
    ;;conflict-pscp-tramp;; (projectile-global-mode)
    (setq projectile-enable-caching t))

  (use-package projectile-explorer
    :config
    (defun project-explorer-close ()
      (interactive)
      (save-excursion
        (save-restriction

          (dolist (buf (buffer-list))
            (with-current-buffer buf
              (if (eq 'project-explorer-mode major-mode)
                  (kill-buffer))))
          (kill-buffer  "*project-explorer*")))))

  (use-package  grep 
    :config
    (defun projectile-grep ()
      "Perform rgrep in the project."
      (interactive)
      (let ((roots (projectile-get-project-directories))
            (search-regexp (if (and transient-mark-mode mark-active)
                               (buffer-substring (region-beginning) (region-end))
                             (read-string (projectile-prepend-project-name "Grep for: ")
                                          (projectile-symbol-at-point)))))
        (dolist (root-dir roots)
          ;; paths for find-grep should relative and without trailing /
          (let ((default-directory root-dir))
            (grep (concat grep-command "\"" search-regexp "\" *")))))))


  ;;(add-hook 'ruby-mode-hook 'projectile-on)

  ;;If you don't like ido you can use regular completion as well:

  ;;(setq projectile-completion-system 'default)

  ;;You might want to combine default completion with icomplete-mode for optimum results.

  ;;Here's a list of the interactive Emacs Lisp functions, provided by projectile:
  ;;Command   Key
  ;;projectile-find-file  C-c p f
  ;;projectile-grep   C-c p g
  ;;projectile-switch-to-buffer   C-c p b
  ;;projectile-multi-occur  C-c p o
  ;;projectile-replace  C-c p r
  ;;projectile-invalidate-cache   C-c p i
  ;;projectile-regenerate-tags  C-c p t
  ;;projectile-kill-buffers   C-c p k
  ;;projectile-dired  C-c p d
  ;;projectile-recentf  C-c p e
  ;;projectile-ack  C-c p a
  ;;projectile-compile-project  C-c p l
  ;;projectile-test-project   C-c p p
  ;;
  ;;If you ever forget any of Projectile's keybindings just do a:

  ;;C-c p C-h

  (with-package* (helm helm-config))
  ;;(global-set-key (kbd "C-c h") 'helm-mini)
  ;;(helm-mode 1)
  ;; https://github.com/emacs-helm/helm/wiki


  (add-hook 'isearch-mode-hook
            (function
             (lambda ()
               (define-key isearch-mode-map "\C-h" 'isearch-mode-help)
               (define-key isearch-mode-map "\C-t" 'isearch-toggle-regexp)
               (define-key isearch-mode-map "\C-c" 'isearch-toggle-case-fold)
               (define-key isearch-mode-map "\C-j" 'isearch-edit-string))))

  ;;(add-to-list 'minor-mode-alist '(case-fold-search " CFS"))

  ;; (require 'xmsi-math-symbols-input)
  (use-package xah-math-input)
  ;;; 관련 변수 확인 
  ;;; major-mode       -> buffer local 
  ;;; minor-mode-list  -> buffer local 
  ;;; minor-mode-alist -> global  
  (add-hook 'prog-mode-hook 'fic-mode)
  (add-hook 'prog-mode-hook 'yafolding-mode)

  ;;notworks;;(require 'jfold-mode)
  ;;notworks;;(add-hook 'nxml-mode-hook 'jfold-mode)


  (require 'hideshow)
  (require 'sgml-mode)
  (require 'nxml-mode)

  (add-to-list 'hs-special-modes-alist
               '(nxml-mode
                 "<!--\\|<[^/>]*[^/]>"
                 "-->\\|</[^/>]*[^/]>"

                 "<!--"
                 sgml-skip-tag-forward
                 nil))

  (add-hook 'nxml-mode-hook 'hs-minor-mode)

  ;; optional key bindings, easier than hs defaults
  (define-key nxml-mode-map (kbd "C-c h") 'hs-toggle-hiding)


  ;;conflict-tramp;;(add-hook 
  ;;conflict-tramp;; 'term-mode-hook 
  ;;conflict-tramp;; (lambda () 
  ;;conflict-tramp;;   (setq comint-use-prompt-regexp t )
  ;;conflict-tramp;;   (define-key term-raw-map [backspace] 'term-send-right)
  ;;conflict-tramp;;   (define-key term-raw-map "\C-c\C-y" 'term-paste)
  ;;conflict-tramp;;   (setq term-prompt-regexp "^->")))

  ;;; https://github.com/leoliu/easy-kill

  ;; w -> word at point
  ;; s -> sexp at point
  ;; f -> file at point
  ;; l -> list at point
  ;; d -> defun at point
  ;; b -> buffer-file-name or default-directory
  ;; @ -> append selection to previous kill
  ;; C-w -> kill selection
  ;; +, - and 0..9 -> expand/shrink selection
  ;; SPC -> turn selection into an active region
  ;; C-g -> abort

  ;; (with-package* (phi-rectangle easy-kill)
  ;;   (defun phi-rectangle-kill-ring-save (&optional n)
  ;;     "when region is active, copy region as usual. when rectangle-region is
  ;; active, copy rectangle. otherwise, copy whole line."
  ;;     (interactive "p")
  ;;     (cond (phi-rectangle-mark-active
  ;;            (phi-rectangle--copy-rectangle (region-beginning) (region-end))
  ;;            (phi-rectangle--delete-trailing-whitespaces (region-beginning) (region-end)))
  ;;           (t (easy-kill n))))
  ;;   (phi-rectangle-mode)
  ;;   ;; (define-key phi-rectangle-mode-map [remap phi-rectangle-kill-ring-save] 'easy-kill)
  ;;   )

  (global-anzu-mode t)


  (require 'loccur)
  ;; http://www.ispl.jp/~oosaki/research/linux-tips/outline/
  (add-hook 
   'diff-mode-hook 
   (lambda ()
     (setq outline-regexp "^\\(diff\\|@@\\|===\\) ")
     (setq 
      outline-level 
      (lambda ()
        (cond ((looking-at "diff") 1) 
              ((looking-at "===") 1) 
              ((looking-at "@@") 2)
              (t 1000)
              )))
     (outline-minor-mode t)
     ))

  (require 'nxml-mode)
  (require 'nxml-util)



  (defun projectile-load-files ()
    (interactive)
    (dolist (p (projectile-current-project-files))
      (if (s-matches? (rxt-pcre-to-elisp ".*(h|cpp|cxx|c)$") p )
          (let ((find-file-hook nil))
            (persp-add-buffer
             (find-file-noselect  (f-join (projectile-project-root)  p ) ))))))

#+END_SRC

#+RESULTS:
: projectile-load-files


* purpose                                                       :deprecated:

#+BEGIN_SRC emacs-lisp :tangle no

;; (with-package*
;;   (perspective)
;;   (persp-mode)
;;   (require 'persp-projectile)
;;   )

(with-package*
  (window-purpose window-purpose-x)
  ;; (if (eq window-system 'w32)  (purpose-mode))  ;;purpose blink grep , dired ..
  (add-to-list 'purpose-user-mode-purposes '(python-mode . py))
  (add-to-list 'purpose-user-mode-purposes '(inferior-python-mode . py-repl))
  (add-to-list 'purpose-user-mode-purposes '(prog-mode . prog))
  (add-to-list 'purpose-user-mode-purposes '(compilation-mode . comp))
  (add-to-list 'purpose-user-mode-purposes '(org-mode . org))

  (add-to-list 'purpose-user-mode-purposes '(mu4e-headers-mode . mu4e-header))
  (add-to-list 'purpose-user-mode-purposes '(mu4e-view-mode  . mu4e-view))

  (purpose-compile-user-configuration)


  (purpose-x-kill-setup)
  )

#+END_SRC



* perspeen
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package perspeen
    :ensure t
    :init
    (setq perspeen-use-tab t)
    :config
    (perspeen-mode))

#+END_SRC
